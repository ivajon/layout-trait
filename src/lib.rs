#![feature(min_specialization)]
use core::ops::Deref;

pub use heapless;

#[derive(Debug)]
pub struct Layout {
    pub address: usize,
    pub size: usize,
}
pub trait GetLayout {
    fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>);
}

impl<T> GetLayout for T {
    default fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>) {
        layout
            .push(Layout {
                address: self as *const _ as usize,
                size: core::mem::size_of_val(self.deref()),
            })
            .unwrap()
    }
}

#[cfg(test)]
mod test {
    use crate::*;
    use heapless::Vec;

    // Notice here tests of Layout can only be done with respect
    // to the `size` field, as the `address` will for these
    // examples refer to data on stack (and thus change between runs)

    #[test]
    fn test_u32() {
        let data: u32 = 32;
        let mut layout: Vec<Layout, 8> = Vec::new();
        data.get_layout(&mut layout);

        assert!(layout[0].size == 4)
    }

    #[test]
    fn test_array_u32() {
        let data: [u32; 16] = [32; 16];

        let mut layout: Vec<Layout, 8> = Vec::new();
        data.get_layout(&mut layout);

        assert!(layout[0].size == 64)
    }

    struct Simple {
        data: u32,
        data2: u64,
    }

    // this implementation should be generated by a custom derive
    impl GetLayout for Simple {
        fn get_layout<const N: usize>(&self, layout: &mut Vec<Layout, N>) {
            // get_layout is executed on each field
            self.data.get_layout(layout);
            self.data2.get_layout(layout);
        }
    }

    #[test]
    fn test_simple() {
        let data = Simple { data: 0, data2: 0 };
        let mut layout: Vec<Layout, 8> = Vec::new();
        data.get_layout(&mut layout);

        assert!(layout[0].size == 4);
        assert!(layout[1].size == 8);
    }

    struct Complex {
        simple: Simple,
        data2: [u64; 2],
    }

    // this implementation should be generated by a custom derive
    impl GetLayout for Complex {
        fn get_layout<const N: usize>(&self, layout: &mut Vec<Layout, N>) {
            // get_layout is executed on each field
            self.simple.get_layout(layout);
            self.data2.get_layout(layout);
        }
    }

    #[test]
    fn test_complex() {
        let data = Complex {
            simple: Simple { data: 0, data2: 0 },
            data2: [0; 2],
        };

        let mut layout: Vec<Layout, 8> = Vec::new();
        data.get_layout(&mut layout);

        assert!(layout[0].size == 4);
        assert!(layout[1].size == 8);
        assert!(layout[2].size == 16);
    }
}
