# layout-trait

A trait providing the `Layout` any type `T`. 

```rust
pub struct Layout {
    pub address: usize,
    pub size: usize,
}

pub trait GetLayout {
    fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>);
}
```

The default implementation treats `&T` as a thin pointer (reference). To allow `no_std` support we rely on `heapless` for the `layout` vector.

To get the layout of a `struct` each field should be added to the layout.

```rust
struct Simple {
    data: u32,
    data2: u64,
}

// this implementation should be generated by a custom derive
impl GetLayout for Simple {
    fn get_layout<const N: usize>(&self, layout: &mut Vec<Layout, N>) {
        // get_layout is executed on each field
        self.data.get_layout(layout);
        self.data2.get_layout(layout);
    }
}
```

A usage example may look like this:

```rust
fn test_simple() {
    let data = Simple { data: 0, data2: 0 };
    let mut layout: Vec<Layout, 8> = Vec::new();
    data.get_layout(&mut layout);

    assert!(layout[0].size == 4);
    assert!(layout[1].size == 8);
}
```

Using specialization the default implementation can be overridden. This currently requires the `nightly` toolchain (`#![feature(min_specialization)]`).

Overriding `get_layout` allows for specialized implementations, e.g., covering resource proxies generated by `svd2rust`, where the layout refers to the dereferenced location (`RegisterBlock`).







