# layout-trait

Traits and data structure for determining the layout of memory objects. It is tailored to the needs for MPU protecting of memory accesses through resources in the [RTIC](https://rtic.rs/) framework.

---

## `Layout`

The `Layout` defines the (start) `address` and `size` (this can be seen a range of addresses).

```rust
pub struct Layout {
    pub address: usize,
    pub size: usize,
}
```

---

## Traits

We define two traits `GetLayoutType` and `GetLayout`, for determining the layout of a memory object. To provide `no_std` support we rely on `heapless` for the `layout` vector.

```rust
pub trait GetLayoutType {
    fn get_layout_type<const N: usize>(layout: &mut heapless::Vec<Layout, N>);
}

impl<T> GetLayoutType for T {
    default fn get_layout_type<const N: usize>(_layout: &mut heapless::Vec<Layout, N>) {}
}
```

Proxies for peripheral register blocks implements the `Deref` trait (automatically generated by `svd2rust`). To get the layout we override the default implementation. This currently requires the `nightly` toolchain (`#![feature(min_specialization)]`). Notice, we assume types that explicitly implement `Deref` to be SZT (and thus can be created out of thin air as seen below). This might cause UB in case of `enums` wrapping `Deref` types, so please take care.

```rust
impl<T, U> GetLayoutType for T
where
    // for now assume this to ZST peripheral proxy
    T: Deref<Target = U>,
{
    default fn get_layout_type<const N: usize>(layout: &mut heapless::Vec<Layout, N>) {
        // hopefully there is a better way to do this
        // for now we crate a &ZST out of thin air!!!
        let t: &T = unsafe { core::mem::transmute(&()) };
        let data = t.deref();
        layout
            .push(Layout {
                address: data as *const _ as usize,
                size: core::mem::size_of_val(data),
            })
            .unwrap();
    }
}
```

To obtain the layout of a reference `&T`, we provide the `GetLayout` trait.

```rust
pub trait GetLayout {
    fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>);
}

impl<T> GetLayout for T
{
    default fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>) {
        layout
            .push(Layout {
                address: self as *const _ as usize,
                size: core::mem::size_of_val(self.deref()),
            })
            .unwrap();

        T::get_layout_type(layout);
    }
}

impl<T, U> GetLayout for T
where
    T: Deref<Target = U>,
{
    fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>) {
        let data = self.deref();
        layout
            .push(Layout {
                address: data as *const _ as usize,
                size: core::mem::size_of_val(data),
            })
            .unwrap();
    }
}
```

As `GetLayoutType` is implemented for all `T`, thus no explicit type bound is required.

---

To handle structured data in the general case, the layout of a `struct` each field should be added to the layout together with the

```rust
struct Simple {
    data: u32,
    data2: u64,
}

// this implementation should be generated by a custom derive
impl GetLayout for Simple {
    fn get_layout<const N: usize>(&self, layout: &mut Vec<Layout, N>) {
        // get_layout is executed on each field
        self.data.get_layout(layout);
        self.data2.get_layout(layout);
    }
}
```

A usage example may look like this:

```rust
fn test_simple() {
    let data = Simple { data: 0, data2: 0 };
    let mut layout: Vec<Layout, 8> = Vec::new();
    data.get_layout(&mut layout);

    assert!(layout[0].size == 4);
    assert!(layout[1].size == 8);
}
```

Notice here, in this case, the `data` will be allocated on the stack, thus the `Layout.address` will vary depending on the stack frame location (and hence not asserted). In the case of tracking the location of RTIC resources, these will be statically allocated and thus their layout will be stable and the `Layout` can be used for MPU supported run-time verification.

--- 


## layout-derive

For convenience, a custom derive macro is provided by [layout-derive](git@github.com:perlindgren/layout-derive.git).

In the `layout-derive` crate you find further examples (including memory layout of real-life peripherals for the ESP32C3).

---

## examples

Under examples you find a set of representative use cases. Some of the examples are replicated in the `layout-derive` crate, and used as reference for expected expansions.

---


## License

For now copyright Per Lindgren, but the intention once stake holder interests have been confirmed, is to release the trait and derive macros under a permissive license.
