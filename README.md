# layout-trait

Traits and data structure for determining the layout of memory objects. It is tailored to the needs for memory accesses through resources in the RTIC framework.

---
## `Layout`

The `Layout` defines the (start) `address` and `size` (this can be seen a range of addresses). 
```rust
pub struct Layout {
    pub address: usize,
    pub size: usize,
}
```

---

## Traits

We define two traits `GetLayoutType` and `GetLayout`, for determining the layout of a memory object. To provide `no_std` support we rely on `heapless` for the `layout` vector.

```rust
pub trait GetLayoutType {
    fn get_layout_type<const N: usize>(layout: &mut heapless::Vec<Layout, N>);
}

impl<T> GetLayoutType for T {
    default fn get_layout_type<const N: usize>(_layout: &mut heapless::Vec<Layout, N>) {}
}
```

To handle cases of zero-sized types (used e.g., as proxies for peripheral register blocks), the layout is determined by type. By default types have no specific layout so `get_layout_type` do not extend the `layout` vector.

The user can override the `GetLayoutType` by means of specialization, as shown below. This currently requires the `nightly` toolchain (`#![feature(min_specialization)]`).


```rust
struct Proxy {}

impl GetLayoutType for Proxy {
    fn get_layout_type<const N: usize>(layout: &mut Vec<Layout, N>) {
        layout
            .push(Layout {
                address: 1024,
                size: 4,
            })
            .unwrap()
    }
}
```

To obtain the layout of a reference `&T`, we provide the `GetLayout` trait.

```rust
pub trait GetLayout {
    fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>);
}

impl<T> GetLayout for T
where
    T: GetLayoutType,
{
    default fn get_layout<const N: usize>(&self, layout: &mut heapless::Vec<Layout, N>) {
        layout
            .push(Layout {
                address: self as *const _ as usize,
                size: core::mem::size_of_val(self.deref()),
            })
            .unwrap();

        T::get_layout_type(layout);
    }
}
```

The default implementation covers primitive types, arrays and references to zero sized types as mentioned above.

---

To handle structured data in the general case, the layout of a `struct` each field should be added to the layout together with the 

```rust
struct Simple {
    data: u32,
    data2: u64,
}

// this implementation should be generated by a custom derive
impl GetLayout for Simple {
    fn get_layout<const N: usize>(&self, layout: &mut Vec<Layout, N>) {
        // get_layout is executed on each field
        self.data.get_layout(layout);
        self.data2.get_layout(layout);
    }
}
```

This works even if fields refer to zero sized types, as the default implementation would kick in.

A usage example may look like this:

```rust
fn test_simple() {
    let data = Simple { data: 0, data2: 0 };
    let mut layout: Vec<Layout, 8> = Vec::new();
    data.get_layout(&mut layout);

    assert!(layout[0].size == 4);
    assert!(layout[1].size == 8);
}
```
---

## layout-derive

For convenience, a custom derive macro is provided by `layout-derive`.

---

## svd2rust

A fork of `svd2rust` provides a PAC with proxies implementing `GetLayoutType` according to the layout of each peripheral `RegisterBlock`

---








